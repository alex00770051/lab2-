# Отчет по лабораторной работе №2
**Выполнил:** Дорофеев Алексей, ИТ-6-2024, Вариант 12

## Задание 1. Заполнение и доступ к элементам. Обратные итераторы.
**Задача 7:** Даны вектор V, дек D и список L. Каждый исходный контейнер содержит не менее двух элементов, количество элементов является четным. Поменять значения двух средних элементов каждого из исходных контейнеров. Использовать алгоритм swap.

### Алгоритм решения:
1. **Ввод данных**
   - Получить количество элементов (четное число ≥ 2)
   - Заполнить вектор, дек и список числами

2. **Определение средних элементов**
   - Для вектора и дека: позиции n/2-1 и n/2 (индексация с 0)
   - Для списка: находим итераторы на позиции n/2-1 и n/2

3. **Обмен значений**
   - Для вектора и дека: используем std::swap с индексами
   - Для списка: используем std::swap с итераторами

**Пример работы:**
```
Входные данные: 
V = [10, 20, 30, 40], D = [1, 2, 3, 4], L = [100, 200, 300, 400]
Результат: 
V = [10, 30, 20, 40], D = [1, 3, 2, 4], L = [100, 300, 200, 400]
```

## Задание 2. Вставка элементов
**Задача 1:** Дан вектор V с четным количеством элементов. Добавить в середину вектора 5 нулевых элементов. Использовать один вызов функции-члена insert.

### Алгоритм решения:
1. **Ввод данных**
   - Получить количество элементов (четное число)
   - Заполнить вектор числами

2. **Определение позиции вставки**
   - Вычисляем среднюю позицию: n/2
   - Позиция вставки: V.begin() + n/2

3. **Вставка элементов**
   - Используем один вызов V.insert()
   - Вставляем 5 элементов со значением 0

**Пример работы:**
```
Входные данные: V = [1, 2, 3, 4, 5, 6]
Результат: V = [1, 2, 3, 0, 0, 0, 0, 0, 4, 5, 6]
```

## Задание 3. Удаление элементов
**Задача 5:** Даны списки L1 и L2; список L1 имеет нечетное количество элементов. Переместить средний элемент списка L1 в конец списка L2. Использовать один вызов функции-члена splice.

### Алгоритм решения:
1. **Ввод данных**
   - Получить количество элементов для L1 (нечетное)
   - Заполнить списки L1 и L2 числами

2. **Поиск среднего элемента**
   - Находим средний элемент списка L1
   - Используем advance для перемещения итератора

3. **Перемещение элемента**
   - Используем один вызов splice
   - Перемещаем средний элемент из L1 в конец L2

**Пример работы:**
```
Входные данные: L1 = [10, 20, 30, 40, 50], L2 = [100, 200]
Результат: L1 = [10, 20, 40, 50], L2 = [100, 200, 30]
```

## Задание 4. Итераторы и алгоритмы.
**Задача 3:** Дан набор вещественных чисел, содержащий не менее двух элементов. Вывести числа из исходного набора с четными порядковыми номерами (т. е. второе число, четвертое число и т. д.). Использовать алгоритм remove_copy_if.

### Алгоритм решения:
1. **Ввод данных**
   - Получить количество чисел (≥ 2)
   - Заполнить вектор вещественными числами

2. **Фильтрация чисел**
   - Используем алгоритм remove_copy_if
   - Счетчик индекса начинается с 1
   - Копируем только элементы с четными индексами (2, 4, 6...)
   - Пропускаем элементы с нечетными индексами (1, 3, 5...)

**Пример работы:**
```
Входные данные: [10.5, 20.3, 30.1, 40.7]
Индексы: 1-10.5(пропустить), 2-20.3(взять), 3-30.1(пропустить), 4-40.7(взять)
Результат: [20.3, 40.7]
```

## Задание 5. Алгоритмы поиска.
**Задача 3:** Дан список L. Удалить первый и последний нулевой элемент списка. Если нулевых элементов нет, то список не изменять, если нулевой элемент всего один, то удалить только его. Использовать два вызова алгоритма find и два вызова функции-члена erase.

### Алгоритм решения:
1. **Поиск нулей**
   - Находим первый ноль (find от начала)
   - Находим последний ноль (find с reverse_iterator)

2. **Обработка случаев**
   - Нет нулей: список без изменений
   - Один ноль: удаляем его
   - Два нуля: удаляем первый и последний

3. **Удаление элементов**
   - Используем erase для удаления найденных элементов

**Пример работы:**
```
Входные данные: L = [1, 0, 2, 0, 3]
Результат: L = [1, 2, 3]
```

## Задание 6. Базовые модифицирующие алгоритмы. Итераторы вставки.
**Задача 12:** Дан дек D с четным количеством элементов. Решить для него задачу 6.11. Поскольку операция вставки делает все итераторы дека недействительными, для решения задачи использовать вспомогательный дек D0.

### Алгоритм решения:
1. **Создание копии**
   - Создаем дек D0 как копию первой половины D

2. **Обработка данных**
   - Обрабатываем дек D0 (задача 6.11)
   - Заменяем отрицательные элементы на 0

3. **Формирование результата**
   - Создаем новый дек из обработанных данных

**Пример работы:**
```
Входные данные: D = [1, -2, 3, -4, 5, -6]
D0 (первая половина): [1, -2, 3]
Результат: [1, 0, 3]
```

## Задание 7. Сортировка и слияние.
**Задача 9:** Дан дек D. Решить для него задачу 7.7, используя один вызов алгоритма stable_sort с параметром — функциональным объектом.

### Алгоритм решения:
1. **Ввод данных**
   - Получить количество элементов
   - Заполнить дек числами

2. **Сортировка по группам**
   - Используем stable_sort с кастомным компаратором
   - Группируем: отрицательные → нули → положительные

3. **Логика компаратора**
   - Отрицательные числа идут первыми
   - Нули идут после отрицательных
   - Положительные числа идут последними

**Пример работы:**
```
Входные данные: D = [3, -1, 0, -2, 1]
Результат: D = [-2, -1, 0, 1, 3]
```

## Задание 8. Численные алгоритмы.
**Задача 1:** Дан список L. Получить вектор V вещественных чисел, содержащий значения среднего арифметического для всех пар соседних элементов исходного списка.

### Алгоритм решения:
1. **Вычисление средних**
   - Используем adjacent_difference с функцией среднего арифметического
   - Для пары (a, b) вычисляем (a + b) / 2.0

2. **Корректировка результата**
   - Удаляем первый элемент (исходный элемент списка)
   - Оставляем только вычисленные средние

**Пример работы:**
```
Входные данные: L = [1, 3, 4, 6]
Результат: V = [2.0, 3.5, 5.0]
```

## Задание 9. Множества.
**Задача 2:** Дан вектор V0, целое число N (> 0) и набор векторов V1, …, VN. Найти количество векторов VI, I = 1, …, N, в которых содержатся все элементы вектора V0 (с учетом их повторений). Использовать алгоритм includes.

### Алгоритм решения:
1. **Создание мультимножеств**
   - Преобразуем V0 в multiset (сохраняем повторения)
   - Для каждого Vi создаем multiset

2. **Проверка вхождения**
   - Используем алгоритм includes
   - Проверяем содержит ли multiset Vi все элементы multiset V0

3. **Подсчет результатов**
   - Считаем количество подходящих векторов

**Пример работы:**
```
V0 = [1, 2, 2], V1 = [1, 2, 3] False, V2 = [1, 2, 2, 3] True
Результат: 1
```

## Задание 10. Отображения.
**Задача 4:** Дан вектор V, элементами которого являются английские слова. Выполнить группировку элементов вектора V, используя в качестве ключа группировки последнюю букву элемента.

### Алгоритм решения:
1. **Группировка слов**
   - Проходим по вектору в обратном порядке
   - Для каждого слова извлекаем последнюю букву

2. **Создание отображения**
   - Используем multimap<char, string>
   - Ключ - последняя буква, значение - слово

3. **Вывод результата**
   - Выводим все пары ключ-значение

**Пример работы:**
```
Входные данные: V = ["CAT", "DOG", "CAR", "BAG"]
Результат: 
G - BAG
G - DOG
R - CAR
T - CAT
```
